package computer;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class CommandParser {

    private static CommandTree commandTree = new CommandTree();

    public static void addCommand( GrammarParser.CommandPair commandPair ) {
        CommandTree.Action action = makeCommand(commandPair.commandArgs);
        commandTree.addCommand(commandPair.command, action);
    }

    public static class ChainedAction implements CommandTree.Action {
        private List<CommandTree.Action> actions;
        public ChainedAction() {
            actions = new ArrayList<CommandTree.Action>();
        }
        public ChainedAction(List<CommandTree.Action> actions){
            this.actions = actions;
        }
        public void addAction(CommandTree.Action action ) {
            this.actions.add( action);
        }
        public void run() {
            for ( CommandTree.Action action : actions ) {
                action.run();
            }
        }
    }

    public static CommandTree.Action makeCommand( List<String> args ) {
        String type = args.remove(0);
        List<String> message = new ArrayList<String>();
        CommandTree.Action action = null;
        if ( type.equals("batch") ) {
            action = makeExternal(args);
        } else if ( type.equals("response") ) {
            action = makeMessage(args);
        } else if ( type.equals("program") ) {
            message.add("Program launching is not yet supported.");
            action = makeMessage(message);
        } else if (type.toLowerCase().equals("do")) {
            action = makeChainedAction(args);
        } else {
            message.add("I don't know how to do that yet.");
            action = makeMessage(message);
        }
        return action;
    }

    public static ChainedAction makeChainedAction( List<String> args ) {
        ChainedAction action = new ChainedAction();
        List<String> nextArgs = new ArrayList<String>();
        for ( String arg : args ) {
            if ( arg.toLowerCase().equals("then")) {
                action.addAction(makeCommand(nextArgs));
                nextArgs.clear();
            } else {
                nextArgs.add( arg );
            }
        }
        action.addAction(makeCommand(nextArgs));
        return action;
    }

    public static CommandTree.MessageAction makeMessage( List<String> args ) {
        String s = "";
        for (String arg : args ) {
            if ( s.length() > 0 ) s += " ";
            s += arg;
        }
        return new CommandTree.MessageAction(s);
    }

    public static CommandTree.ExternalAction makeExternal( List<String> args) {
        String message = "";
        if (args.size() > 1 ) {
            message = args.get(1);
        }
        return new CommandTree.ExternalAction(message, args.get(0));
    }

    /**
     * Runs a list of commands as generated by the VoiceInterface.
     * @param commands
     */
    public static void RunCommands( String commands ) {
        String[] commandList = commands.split("computer");
        for ( String command : commandList ) {
            runCommand( command );
        }
    }

    /**
     * Parses and runs a single command, without the address
     * @param command
     */
    private static void runCommand( String command ) {
        System.out.println("Running command: " + command);
        commandTree.runCommand("computer " + command.trim());
    }

    public static void printCommandTree() {
        commandTree.printTree();
    }
}
